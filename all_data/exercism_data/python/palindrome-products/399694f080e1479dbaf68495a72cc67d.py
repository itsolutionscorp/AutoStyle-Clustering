from itertools import product
from math import ceil

def find_first_product(iterator,max_factor,min_factor=0):
	"""Finds the first number returned by iterator which can be expressed as a product of numbers between min_factor and max_factor, along with its factors within that range.

	Returns [None,None] if no such product is returned by iterator.
	"""
	bottom = max(min_factor,1)
	for target in iterator:
		for i in range(bottom,max_factor+1):
			d,m = divmod(target,i)
			if m == 0 and min_factor <= d <= max_factor:
				return [target,[i,d]]
	return [None,None]

def palindrome_pieces(digits):
	"""Returns a list of those numbers (in reverse sorted order) from which a palindrome number with digits digits is made by linear combination.

	e.g. palindrome_pieces(5) is [10001, 1010, 100]
	     palindrome_pieces(6) is [100001, 10010, 1100]
	"""
	if digits <= 0:
		return []
	elif digits == 1:
		return [1]
	else:
		return [10**(digits-1)+1] + [n*10 for n in palindrome_pieces(digits-2)]

def make_linear_combination(coefficients,values):
	"""Returns the sum of the product of each element of coefficients and values.

	coefficients and values must be iterables with len(values)>=len(coefficients).
	Coefficients not included are assumed to be 0.
	"""
	return sum([coefficients[i]*values[i] for i in range(len(coefficients))])

def _normalize(thing):
	"""Changes an iterable of iterables of iterables, etc into a list of objects."""
	if not hasattr(thing,"__iter__"):
		return [thing]
	pieces = [ _normalize(part) for part in thing ]
	answer = []
	for part in pieces:
		answer.extend(part)
	return answer

def linear_combination_generator(coefficient_iterator,values):
	"""Generates all the linear combinations of values with coefficients generated by coefficient_iterator.

	Note: coefficient_iterator's output will be normalized to a list of objects.
	"""
	for coefficients in coefficient_iterator:
		yield make_linear_combination(_normalize(coefficients),values)

def smallest_palindrome(max_factor,min_factor=0):
	"""Returns the smallest palindrome number (in base 10) which can be expressed as a product of numbers between min_factor and max_factor (inclusive), along with its factors within that range.

	Returns [None,None] if no such palindrome number exists.
	"""
	min_digits = len(str(min_factor**2))
	max_digits = len(str(max_factor**2))
	for digits in range(min_digits,max_digits+1):
		palindrome_iterator = linear_combination_generator(product(range(1,10),product(range(10),repeat=ceil(digits/2)-1)),palindrome_pieces(digits))
		answer = find_first_product(palindrome_iterator,max_factor,min_factor)
		if answer != [None,None]:
			return answer
	return [None,None]

def largest_palindrome(max_factor,min_factor=0):
	"""Returns the largest palindrome number (in base 10) which can be expressed as a product of numbers between min_factor and max_factor (inclusive), along with its factors within that range.

	Returns [None,None] if no such palindrome number exists.
	"""
	min_digits = len(str(min_factor**2))
	max_digits = len(str(max_factor**2))
	for digits in range(max_digits,min_digits-1,-1):
		palindrome_iterator = linear_combination_generator(product(range(9,0,-1),product(range(9,-1,-1),repeat=ceil(digits/2)-1)),palindrome_pieces(digits))
		answer = find_first_product(palindrome_iterator,max_factor,min_factor)
		if answer != [None,None]:
			return answer
	return [None,None]
