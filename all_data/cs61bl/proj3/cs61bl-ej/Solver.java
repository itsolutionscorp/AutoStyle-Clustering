import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

/**
 * A class that represents a solver for sliding block puzzles.
 */

public class Solver {

	/**
	 * A PriorityQueue that contains trays that have not been processed.
	 */
	private PriorityQueue<Tray> fringe;

	/**
	 * An integer that represents the index of the bucket that contains empty squares.
	 */
	private int empty_square_bucket_number; 

	/**
	 * A HashMap mapping current trays to their previous (or parent) trays.
	 */
	private HashMap<Tray, Tray> steps; 

	/**
	 * A TreeSet containing all the trays that are already visited, which are represented
	 * by their blocks.
	 */
	private TreeSet<ArrayList<ArrayList<int[]>>> visited; 

	/**
	 * The initial tray.
	 */
	Tray init;

	/**
	 * The goal tray.
	 */
	static Tray goal; 

	/**
	 * The height of the tray.
	 */
	private int tray_height;

	/**
	 * The width of the tray.
	 */
	private int tray_width;

	/**
	 * A HashMap mapping the bucket index of each bucket from goal.blocks to 
	 * the bucket index of the bucket in init.blocks that corresponds to the same dimension.
	 */
	private HashMap<Integer, Integer> goal_init;

	/**
	 * A HashMap mapping block dimension represented by its hash code
	 * generated by dimensionHashCode() to the corresponding bucket index in blocks.
	 */
	private HashMap<Integer, Integer> dim_bucket;

	/**
	 * The initial capacity of the priority queue.
	 */
	private static final int PQ_INITIAL_CAPACITY = 256;

	//	private static int count = 0;

	/**
	 * A boolean indicating whether the optimization mode "LowEmpty" is on.
	 */
	private static boolean optimizeLowEmpty = false;

	/**
	 * A boolean indicating whether the optimization mode "HighEmpty" is on.
	 */
	private static boolean optimizeHighEmpty = false;


	public Solver() {
		fringe = new PriorityQueue<Tray>(PQ_INITIAL_CAPACITY, new TrayHeuristicComparator());
		empty_square_bucket_number = 0;
		steps = new HashMap<Tray, Tray>();
		visited = new TreeSet<ArrayList<ArrayList<int[]>>>(new TrayBlocksComparator());
		init = null;
		goal = null; 
		tray_height = 0;
		tray_width = 0;
		goal_init = new HashMap<Integer, Integer>();
		dim_bucket= new HashMap<Integer, Integer>();
	}

	public void createInitOrGoal(String file, boolean used_for_init) {
		// citation: https://www.caveofprogramming.com/java/java-file-reading-and-writing-files-in-java.html

		// This will reference one line at a time
		String file_line = null;

		try {
			// FileReader reads text files in the default encoding.
			FileReader fileReader = 
					new FileReader(file);

			// Always wrap FileReader in BufferedReader.
			BufferedReader bufferedReader = 
					new BufferedReader(fileReader);

			boolean[][] occupation = null;
			if (used_for_init) {
				// check if the first line is formatted correctly
				file_line = bufferedReader.readLine();
				String[] first_line = file_line.split(" ");
				if (first_line.length != 2) {
					printError("Invalid init and/or goal file.");
				}
				try {
					tray_height = Integer.parseInt(first_line[0]);
					tray_width = Integer.parseInt(first_line[1]);
					if (tray_height < 1 || tray_width < 1 || tray_height > 256 || tray_width > 256) {
						printError("Invalid init and/or goal file.");
					}
				} catch (NumberFormatException e) {
					printError("Invalid init and/or goal file.");
				}

			} 
			occupation = new boolean[tray_height][tray_width];

			// since we don't know the number of lines of the file, 
			// we create an ArrayList to temporarily hold the lines
			HashMap<ArrayList<Integer>, Integer> buckets = new HashMap<ArrayList<Integer>, Integer>();
			int bucketIndex = 0; 
			ArrayList<ArrayList<int[]>> blocks = new ArrayList<ArrayList<int[]>>(); // crazy 3-d structure 
			while((file_line = bufferedReader.readLine()) != null) {
				String[] line = file_line.split(" "); 
				if (line.length != 4) {
					printError("Invalid init and/or goal file.");
				}

				int[] temp = new int[4]; 
				for (int i = 0; i < 4; i++) {
					try {
						temp[i] = Integer.parseInt(line[i]); 	
					}
					catch (NumberFormatException e) {
						printError("Invalid init and/or goal file.");
					}
				}
				// Set the squares covered by the current block to true
				coverSquares(occupation, temp);
				int height = temp[2] - temp[0] + 1; 
				int width = temp[3] - temp[1] + 1;
				ArrayList<Integer> dimensions = new ArrayList<Integer>();
				dimensions.add(height); 
				dimensions.add(width);
				Integer index = buckets.get(dimensions);
				if (index == null) {
					buckets.put(dimensions, bucketIndex);
					// must make new ArrayList
					ArrayList<int[]> a = new ArrayList<int[]>(); 
					blocks.add(a);
					index = bucketIndex; 
					bucketIndex++; 
				} 
				// else bucket dimension already exists
				// add block to this bucket 
				blocks.get(index).add(temp);
			}
			// Get the empty squares from occupation
			ArrayList<int[]> a =  new ArrayList<int[]>(); 
			for (int i = 0; i < tray_height; i++) {
				for (int j = 0; j < tray_width; j++) {
					if (occupation[i][j] == false) {
						// represent empty squares as 1 by 1 blocks with only 2 numbers
						int[] temp = new int[2];
						temp[0] = i;
						temp[1] = j;
						a.add(temp); 
					}
				}
			}
			blocks.add(a);

			// Sort each bucket in blocks
			for (ArrayList<int[]> bucket : blocks) {
				Collections.sort(bucket, new BlockComparator());
			}
			// Sort all buckets in blocks in increasing order according to bucket size
			Collections.sort(blocks, new BucketComparator());

			// close files
			bufferedReader.close();

			// now we got blocks, so instantiate a new tray 
			if (used_for_init) {
				// find the bucket number of empty squares
				// and update empty_square_bucket_number
				int i = 0;
				for (ArrayList<int[]> bucket : blocks) {
					if (bucket.isEmpty() || bucket.get(0).length == 2) {
						// the bucket that contains empty squares is either:
						// empty or has block with length of 2
						empty_square_bucket_number = i;


					}
					i++;
				}

				// update HashSet empty_squares 
				HashSet<Integer> empty_squares = new HashSet<Integer>();
				for (int[] empty_square : blocks.get(empty_square_bucket_number)) {
					empty_squares.add(emptySquareHashCode(empty_square)); 
				}



				init = new Tray(blocks, empty_squares, null);
				i = 0;
				// Update dim_bucket and check_empty
				for (ArrayList<int[]> bucket : blocks) {
					if (bucket.isEmpty() || bucket.get(0).length == 2) {
						dim_bucket.put(0, i);
					}
					else {
						int [] temp = bucket.get(0);
						int height = temp[2] - temp[0] + 1;
						int width = temp[3] - temp[1] + 1;
						dim_bucket.put(dimensionHashCode(height, width), i);
					}
					i++;
				}
			} else {
				
				// Update goal_init
				int i = 0;
				for (ArrayList<int[]> bucket : blocks) {
					if (bucket.isEmpty() || bucket.get(0).length == 2) {
						goal_init.put(i, dim_bucket.get(0));
					}
					else {
						int [] temp = bucket.get(0);
						int height = temp[2] - temp[0] + 1;
						int width = temp[3] - temp[1] + 1;
						int dimHash = dimensionHashCode(height, width);
						ArrayList<int[]> init_bucket = init.blocks.get(dim_bucket.get(dimHash));
						if (init_bucket.size() < bucket.size()) {
							printError("Invalid init and/or goal file.");
						}
						goal_init.put(i, dim_bucket.get(dimHash));
					}
					i++;
				}

				// goal has no empty square hashset 
				goal = new Tray(blocks, null, null);
			}




		}
		catch(FileNotFoundException ex) {  
		}
		catch(IOException ex) {
		}
	}

	/**
	 * Calculates the hash code for a block dimension.
	 * @param height
	 * @param width
	 * @return
	 */
	static int dimensionHashCode(int height, int width) {
		return 1024 * height + width;
	}

	/**
	 * Calculates the hash code for an empty square.
	 * @param height
	 * @param width
	 * @return
	 */
	private static int emptySquareHashCode(int[] arr) {
		return 1024 * arr[0] + arr[1];
	}

	/**
	 * Covers squares that are covered by block.
	 * @param occupation
	 * @param block  it must be non-empty
	 */
	private void coverSquares(boolean[][] occupation, int[] block) {
		for (int i = block[0]; i <= block[2]; i++) {
			for (int j = block[1]; j <= block[3]; j++) {
				try {
					if (occupation[i][j] == true) {
						printError("Invalid init and/or goal file.");
					}
					occupation[i][j] = true; 
				} catch (ArrayIndexOutOfBoundsException e) {
					printError("Invalid init and/or goal file.");
				}
			}
		}
	}

	/**
	 * Searches a path that cab solve the puzzle.
	 */
	private void searchPath() {
		// add the initial tray to fringe and visited
		fringe.offer(init);

		// process fringe until it is empty or the path is found
		while(!fringe.isEmpty()) {
			Tray curr = fringe.poll();
			// printTray(curr);

			// check if curr is goal (goal is contained in curr)
			if (currIsGoal(curr)) {
				// print the path
				printPath(curr);
				break;
			}

			// curr is not goal
			// add curr to visited
			visited.add(blocksClone(curr.blocks)); // ownership of object! need deep copy!
			ArrayList<Tray> children = null;

			if (optimizeLowEmpty) {
				optimizeLowEmptyPath();
				return;
			}
			else {
				children = generateTrays(curr);
			}

			for (Tray t : children) {
				fringe.offer(t);

				// add (t, curr) to steps
				steps.put(t, curr);
			}

			// impossible to solve -- print nothing

		}

	}

	/**
	 * Prints the path in optimization mode "LowEmpty".
	 */
	private void optimizeLowEmptyPath() {
		// look at adjecent squares to the empty square
		int[] empty = init.blocks.get(0).get(0);
		int[] empty_goal = goal.blocks.get(0).get(0);

		boolean goal_y_greater = empty[0] <= empty_goal[0];
		boolean goal_x_greater = empty[1] <= empty_goal[1];

		if (goal_y_greater && goal_x_greater) {
			// first go right, then go down (Miami)
			while (empty[1] != empty_goal[1]) {
				System.out.println(empty[0] + " " + (empty[1] + 1) + " " + empty[0] + " " + empty[1]);
				empty[1]++;
			}
			while (empty[0] != empty_goal[0]) {
				System.out.println((empty[0] + 1) + " " + empty[1] + " " + empty[0] + " " + empty[1]);
				empty[0]++;
			}

		} else if (!goal_y_greater && !goal_x_greater) {
			// first go left, then go up (Seattle)
			while (empty[1] != empty_goal[1]) {
				System.out.println(empty[0] + " " + (empty[1] - 1) + " " + empty[0] + " " + empty[1]);
				empty[1]--;
			}
			while (empty[0] != empty_goal[0]) {
				System.out.println((empty[0] - 1) + " " + empty[1] + " " + empty[0] + " " + empty[1]);
				empty[0]--;
			}

		} else if (goal_y_greater && !goal_x_greater) {
			// first go left, then go down (California)
			while (empty[1] != empty_goal[1]) {
				System.out.println(empty[0] + " " + (empty[1] - 1) + " " + empty[0] + " " + empty[1]);
				empty[1]--;
			}
			while (empty[0] != empty_goal[0]) {
				System.out.println((empty[0] + 1) + " " + empty[1] + " " + empty[0] + " " + empty[1]);
				empty[0]++;
			}

		} else {
			// first go right, then go up (New York)
			while (empty[1] != empty_goal[1]) {
				System.out.println(empty[0] + " " + (empty[1] + 1) + " " + empty[0] + " " + empty[1]);
				empty[1]++;
			}
			while (empty[0] != empty_goal[0]) {
				System.out.println((empty[0] - 1) + " " + empty[1] + " " + empty[0] + " " + empty[1]);
				empty[0]--;
			}
		}
	}

	//		private void printTray(Tray t) {
	//			System.out.print(count + " calls to this function!\n");
	//			count++;
	//			
	//			boolean[][] occupation = new boolean[tray_height][tray_width];
	//			for (ArrayList<int[]> t_bucket : t.blocks) {
	//				for (int[] g_block : t_bucket) {
	//					if (g_block.length != 2) {
	//						coverSquares(occupation, g_block);
	//					}
	//				}
	//			}
	//			
	//			// print the tray
	//			for (int i = 0; i < tray_height; i++) {
	//				for (int j = 0; j < tray_width; j++) {
	//					if (occupation[i][j] == true) {
	//						System.out.print("|*");
	//					} else {
	//						System.out.print("| ");
	//					}
	//				}
	//				System.out.print("|\n");
	//			}
	//			
	//			System.out.print("\n\n\n\n\n");
	//		}

	/**
	 * Checks optimization possibilities.
	 */
	private void checkOptimizationPossibilities () {
		// check for case where only 1 empty block
		optimizeForFewEmpty();

		// check for case where empty squares are most common
		optimizeForHighEmpty();
	}

	/**
	 * Checks if the given configuration fits optimization case "FewEmpty".
	 */
	private void optimizeForFewEmpty () {
		// check if there are only 2 buckets for dimension and if the empty squares are least common
		// ex: 999 1x1 blocks and 1 empty block 

		if (init.blocks.size() == 2 && empty_square_bucket_number == 0 
				&& init.blocks.get(0).size() == 1 && dim_bucket.get(dimensionHashCode(1, 1)) == 1) {
			if (goal.blocks.size() == 2 && goal.blocks.get(0).size() == 1 && goal.blocks.get(0).get(0).length == 2
					&& goal.blocks.get(1).size() == init.blocks.get(1).size())
				optimizeLowEmpty = true;
		}
	}

	/**
	 * Checks if the given configuration fits optimization case "HighEmpty".
	 */
	private void optimizeForHighEmpty () {
		// check if empty blocks are most common. If so, apply distance heuristic 
		if (empty_square_bucket_number == init.blocks.size() - 1) {
			optimizeHighEmpty = true;
		}
	}

	/**
	 * Prints the path that solves the puzzle.
	 * @param curr
	 */
	private void printPath(Tray curr) {
		// follow steps
		Stack<Tray> reversePath = new Stack<Tray>();
		while (curr.id != init.id) {
			reversePath.push(curr);
			curr = steps.get(curr);
		}
		// edge case: what if init is goal?

		// print path
		while (!reversePath.isEmpty()) {
			int[] move = reversePath.pop().move;
			String move_string = move[0] + " " + move[1] + " " + move[2] + " " + move[3];
			System.out.println(move_string);
		}

	}

	/**
	 * Checks if the current tray t contains the goal configuration.
	 * @param t
	 * @return
	 */
	private boolean currIsGoal(Tray t) {
		//iterate through all goal blocks

		//for each block, search in the arraylist of blocks for the given tray
		//if a match, return true
		//else return false
		int i = 0;
		for (ArrayList<int[]> g_bucket : goal.blocks) {
			ArrayList<int[]> t_bucket = t.blocks.get(goal_init.get(i));
			// check if bucket is empty, if empty, skip
			if (t_bucket.isEmpty() || t_bucket.get(0).length == 2) {
				i++;
				continue;
			}
			for (int[] g_block : g_bucket) {
				if (Collections.binarySearch(t_bucket, g_block, new BlockComparator()) < 0) {
					// if false, that means t doesn't contain this goal block
					return false;
				}
			}
			i++;
		}
		return true;
	}

	/**
	 * Generates new trays from the current tray t.
	 * @param t
	 * @return
	 */
	public ArrayList<Tray> generateTrays(Tray t) {
		ArrayList<Tray> rtn = new ArrayList<Tray>();
		// go through all the blocks in t and for each one, see if they can move up, down, right or left
		// for each move, see if the move is in visited
		// if it is not visited, instantiate the new tray object
		int t_blocks_size = t.blocks.size();
		for (int i = 0; i < t_blocks_size; i++) {
			if (i == empty_square_bucket_number) {
				continue;
			}
			// for this t_bucket it should always revert to the original state
			int bucket_size = t.blocks.get(i).size();
			for (int j = 0; j < bucket_size; j++) {

				tryMoveUp(t, i, j, rtn);

				tryMoveDown(t, i, j, rtn);

				tryMoveLeft(t, i, j, rtn);

				tryMoveRight(t, i, j, rtn);

			}
		}

		return rtn;
	}

	/**
	 * Clones blocks.
	 * @param blocks
	 * @return
	 */
	private ArrayList<ArrayList<int[]>> blocksClone(ArrayList<ArrayList<int[]>> blocks) {
		ArrayList<ArrayList<int[]>> rtn = new ArrayList<ArrayList<int[]>>();
		for (ArrayList<int[]> bucket : blocks) {
			rtn.add(bucketClone(bucket));
		}
		return rtn;
	}

	/**
	 * Clones bucket.
	 * @param bucket
	 * @return
	 */
	private ArrayList<int[]> bucketClone(ArrayList<int[]> bucket) {
		ArrayList<int[]> rtn = new ArrayList<int[]>();
		if (bucket.isEmpty()) {
			return rtn;
		}
		int len = bucket.get(0).length;
		for (int i = 0; i < bucket.size(); i++) {
			int[] copy = Arrays.copyOf(bucket.get(i), len);
			rtn.add(copy);
		}
		return rtn;
	}

	/**
	 * Tries to move a block up.
	 * @param t
	 * @param t_bucket_index
	 * @param t_block_index
	 * @param rtn
	 */
	private void tryMoveUp(Tray t, int t_bucket_index,
			int t_block_index, ArrayList<Tray> rtn) {
		ArrayList<int[]> t_bucket = t.blocks.get(t_bucket_index);
		int[] t_block = t_bucket.get(t_block_index);

		int[] moveUp = moveUp(t_block, t);
		if (moveUp != null) {
			// clone the bucket in which t_block is contained 
			// and clone the bucket containing empty squares
			ArrayList<int[]> t_block_bucket_save = bucketClone(t_bucket);
			ArrayList<int[]> empty_bucket_save = bucketClone(t.blocks.get(empty_square_bucket_number));

			// it can move :)
			// move the block by modifying int[] t_block and the bucket containing empty squares 
			// as well as making a deep copy of empty_squares and modify it
			// then sort both t_bucket and the bucket containing empty squares
			// check if visited.contains(t.blocks)
			// (1) if it is not visited, instantiate the new tray called new_tray by deep copying
			//     t.blocks (which is already modified)
			// (2) if it is already visited, do nothing
			// no matter whether it is already visited or not, revert t.blocks back by replacing
			// with t_block_bucket_save and empty_bucket_save

			// move the block
			// height increases in the downwards direction, so moving up decreases height
			int t_block_2_save = t_block[2];
			t_block[0]--;
			t_block[2]--;

			// modify the empty squares bucket and empty_squares HashSet
			ArrayList<int[]> empty_bucket = t.blocks.get(empty_square_bucket_number);
			HashSet<Integer> new_empty_squares = new HashSet<Integer>(t.empty_squares); // copy ctor
			// go through all the above spots
			for (int j = t_block[1]; j <= t_block[3]; j++) {
				int empty_square_index = 
						Collections.binarySearch(empty_bucket, new int[] {t_block[0], j}, new BlockComparator());
				int[] empty_square_to_modify = empty_bucket.get(empty_square_index);
				// modify the HashSet by first removing and then adding
				new_empty_squares.remove(emptySquareHashCode(empty_square_to_modify));
				empty_square_to_modify[0] = t_block_2_save;
				new_empty_squares.add(emptySquareHashCode(empty_square_to_modify));
				bucketSort(empty_bucket, new BlockComparator(), empty_square_index);
			}

			// sort one bucket
			bucketSort(t_bucket, new BlockComparator(), t_block_index);


			// check if visited.contains(t.blocks)
			if (!visited.contains(t.blocks)) {
				if (optimizeHighEmpty) {
					rtn.add(new Tray(blocksClone(t.blocks), new_empty_squares, moveUp, t_block, t));
				}
				rtn.add(new Tray(blocksClone(t.blocks), new_empty_squares, moveUp));
			}

			// revert t.blocks
			t.blocks.set(t_bucket_index, t_block_bucket_save);
			t.blocks.set(empty_square_bucket_number, empty_bucket_save);

		} 

	}

	/**
	 * Tries to move a block down.
	 * @param t
	 * @param t_bucket_index
	 * @param t_block_index
	 * @param rtn
	 */
	private void tryMoveDown(Tray t, int t_bucket_index,
			int t_block_index, ArrayList<Tray> rtn) {
		ArrayList<int[]> t_bucket = t.blocks.get(t_bucket_index);
		int[] t_block = t_bucket.get(t_block_index);

		int[] moveDown = moveDown(t_block, t);
		if (moveDown != null) {
			// clone the bucket in which t_block is contained 
			// and clone the bucket containing empty squares
			ArrayList<int[]> t_block_bucket_save = bucketClone(t_bucket);
			ArrayList<int[]> empty_bucket_save = bucketClone(t.blocks.get(empty_square_bucket_number));


			// move the block
			// height decreases in the upwards direction, so moving down increases height
			int t_block_0_save = t_block[0];
			t_block[0]++;
			t_block[2]++;

			// modify the empty squares bucket and empty_squares HashSet
			ArrayList<int[]> empty_bucket = t.blocks.get(empty_square_bucket_number);
			HashSet<Integer> new_empty_squares = new HashSet<Integer>(t.empty_squares); // copy ctor
			// go through all the spots below 
			for (int j = t_block[1]; j <= t_block[3]; j++) {
				int empty_square_index = 
						Collections.binarySearch(empty_bucket, new int[] {t_block[2], j}, new BlockComparator());
				int[] empty_square_to_modify = empty_bucket.get(empty_square_index);
				// modify the HashSet by first removing and then adding
				new_empty_squares.remove(emptySquareHashCode(empty_square_to_modify));
				empty_square_to_modify[0] = t_block_0_save;
				new_empty_squares.add(emptySquareHashCode(empty_square_to_modify));
				bucketSort(empty_bucket, new BlockComparator(), empty_square_index);
			}

			// sort one bucket
			bucketSort(t_bucket, new BlockComparator(), t_block_index);


			// check if visited.contains(t.blocks)
			if (!visited.contains(t.blocks)) {
				if (optimizeHighEmpty) {
					rtn.add(new Tray(blocksClone(t.blocks), new_empty_squares, moveDown, t_block, t));
				}
				rtn.add(new Tray(blocksClone(t.blocks), new_empty_squares, moveDown));
			}

			// revert t.blocks
			t.blocks.set(t_bucket_index, t_block_bucket_save);
			t.blocks.set(empty_square_bucket_number, empty_bucket_save);

		} 

	}

	/**
	 * Tries to move a block to the left.
	 * @param t
	 * @param t_bucket_index
	 * @param t_block_index
	 * @param rtn
	 */
	private void tryMoveLeft(Tray t, int t_bucket_index,
			int t_block_index, ArrayList<Tray> rtn) {
		ArrayList<int[]> t_bucket = t.blocks.get(t_bucket_index);
		int[] t_block = t_bucket.get(t_block_index);

		int[] moveLeft = moveLeft(t_block, t);
		if (moveLeft != null) {
			// clone the bucket in which t_block is contained 
			// and clone the bucket containing empty squares
			ArrayList<int[]> t_block_bucket_save = bucketClone(t_bucket);
			ArrayList<int[]> empty_bucket_save = bucketClone(t.blocks.get(empty_square_bucket_number));


			// move the block
			// width decreases in the left direction, so moving left decreases width
			int t_block_3_save = t_block[3];
			t_block[1]--;
			t_block[3]--;

			// modify the empty squares bucket and empty_squares HashSet
			ArrayList<int[]> empty_bucket = t.blocks.get(empty_square_bucket_number);
			HashSet<Integer> new_empty_squares = new HashSet<Integer>(t.empty_squares); // copy ctor
			// go through all the left spots 
			for (int j = t_block[0]; j <= t_block[2]; j++) {
				int empty_square_index = 
						Collections.binarySearch(empty_bucket, new int[] {j, t_block[1]}, new BlockComparator());
				int[] empty_square_to_modify = empty_bucket.get(empty_square_index);
				// modify the HashSet by first removing and then adding
				new_empty_squares.remove(emptySquareHashCode(empty_square_to_modify));
				empty_square_to_modify[1] = t_block_3_save;
				new_empty_squares.add(emptySquareHashCode(empty_square_to_modify));
				bucketSort(empty_bucket, new BlockComparator(), empty_square_index);
			}

			// sort one bucket
			bucketSort(t_bucket, new BlockComparator(), t_block_index);


			// check if visited.contains(t.blocks)
			if (!visited.contains(t.blocks)) {
				if (optimizeHighEmpty) {
					rtn.add(new Tray(blocksClone(t.blocks), new_empty_squares, moveLeft, t_block, t));
				}
				rtn.add(new Tray(blocksClone(t.blocks), new_empty_squares, moveLeft));
			}

			// revert t.blocks
			t.blocks.set(t_bucket_index, t_block_bucket_save);
			t.blocks.set(empty_square_bucket_number, empty_bucket_save);

		} 

	}

	/**
	 * Tries to move a block to the right.
	 * @param t
	 * @param t_bucket_index
	 * @param t_block_index
	 * @param rtn
	 */
	private void tryMoveRight(Tray t, int t_bucket_index,
			int t_block_index, ArrayList<Tray> rtn) {
		ArrayList<int[]> t_bucket = t.blocks.get(t_bucket_index);
		int[] t_block = t_bucket.get(t_block_index);

		int[] moveRight = moveRight(t_block, t);
		if (moveRight != null) {
			// clone the bucket in which t_block is contained 
			// and clone the bucket containing empty squares
			ArrayList<int[]> t_block_bucket_save = bucketClone(t_bucket);
			ArrayList<int[]> empty_bucket_save = bucketClone(t.blocks.get(empty_square_bucket_number));


			// move the block
			// width increases in the right direction, so moving right increases width
			int t_block_1_save = t_block[1];
			t_block[1]++;
			t_block[3]++;

			// modify the empty squares bucket and empty_squares HashSet
			ArrayList<int[]> empty_bucket = t.blocks.get(empty_square_bucket_number);
			HashSet<Integer> new_empty_squares = new HashSet<Integer>(t.empty_squares); // copy ctor
			// go through all the right spots 
			for (int j = t_block[0]; j <= t_block[2]; j++) {
				int empty_square_index = 
						Collections.binarySearch(empty_bucket, new int[] {j, t_block[3]}, new BlockComparator());
				int[] empty_square_to_modify = empty_bucket.get(empty_square_index);
				// modify the HashSet by first removing and then adding
				new_empty_squares.remove(emptySquareHashCode(empty_square_to_modify));
				empty_square_to_modify[1] = t_block_1_save;
				new_empty_squares.add(emptySquareHashCode(empty_square_to_modify));
				bucketSort(empty_bucket, new BlockComparator(), empty_square_index);
			}

			// sort one bucket
			bucketSort(t_bucket, new BlockComparator(), t_block_index);



			// check if visited.contains(t.blocks)
			if (!visited.contains(t.blocks)) {
				if (optimizeHighEmpty) {
					rtn.add(new Tray(blocksClone(t.blocks), new_empty_squares, moveRight, t_block, t));
				}
				rtn.add(new Tray(blocksClone(t.blocks), new_empty_squares, moveRight));
			}

			// revert t.blocks
			t.blocks.set(t_bucket_index, t_block_bucket_save);
			t.blocks.set(empty_square_bucket_number, empty_bucket_save);

		} 

	}

	/**
	 * Moves a block up by one step.
	 * @param t_block
	 * @param t
	 * @return
	 */
	private int[] moveUp(int[] t_block, Tray t) {
		// go through all the above spots
		for (int j = t_block[1]; j <= t_block[3]; j++) {
			int[] empty_candidate = new int[] {t_block[0] - 1, j};
			// check if emptySquareHashCode is out of bounds
			// or empty_candidate is out of bounds 
			if (outOfBound(empty_candidate) || !t.empty_squares.contains(emptySquareHashCode(empty_candidate))) {

				return null;
			}
		}
		return new int[] {t_block[0], t_block[1], t_block[0] - 1, t_block[1]};
	}

	/**
	 * Checks if the empty square represented by empty_candidate is out of the boundary of the tray.
	 * @param empty_candidate
	 * @return
	 */
	private boolean outOfBound(int[] empty_candidate) {
		return (empty_candidate[0] < 0 || empty_candidate[0] >= tray_height || 
				empty_candidate[1] < 0 || empty_candidate[1] >= tray_width);
	}

	/**
	 * Moves a block down by one step.
	 * @param t_block
	 * @param t
	 * @return
	 */
	private int[] moveDown(int[] t_block, Tray t) {
		// go through all the spots below
		for (int j = t_block[1]; j <= t_block[3]; j++) {
			int[] empty_candidate = new int[] {t_block[2] + 1, j};
			if (outOfBound(empty_candidate) || !t.empty_squares.contains(emptySquareHashCode(empty_candidate))) {
				return null;
			}
		}
		return new int[] {t_block[0], t_block[1], t_block[0] + 1, t_block[1]};
	}

	/**
	 * Moves a block to the left by one step.
	 * @param t_block
	 * @param t
	 * @return
	 */
	private int[] moveLeft(int[] t_block, Tray t) {
		// go through all the left spots 
		for (int j = t_block[0]; j <= t_block[2]; j++) {
			int[] empty_candidate = new int[] {j, t_block[1] - 1};
			if (outOfBound(empty_candidate) || !t.empty_squares.contains(emptySquareHashCode(empty_candidate))) {
				return null;
			}
		}
		return new int[] {t_block[0], t_block[1], t_block[0], t_block[1] - 1};
	}

	/**
	 * Moves a block to the right by one step.
	 * @param t_block
	 * @param t
	 * @return
	 */
	private int[] moveRight(int[] t_block, Tray t) {
		// go through all the right spots 
		for (int j = t_block[0]; j <= t_block[2]; j++) {
			int[] empty_candidate = new int[] {j, t_block[3] + 1};
			if (outOfBound(empty_candidate) || !t.empty_squares.contains(emptySquareHashCode(empty_candidate))) {
				return null;
			}
		}
		return new int[] {t_block[0], t_block[1], t_block[0], t_block[1] + 1};
	}

	/**
	 * Sorts a bucket assuming all blocks are in order except the one at block_index.
	 * @param bucket
	 * @param c
	 * @param block_index
	 */
	static void bucketSort(ArrayList<int[]> bucket, Comparator<int[]> c, int block_index) {
		int[] curr_block = bucket.get(block_index);
		if (bucket.size() == 1) {
			return;
		}
		if (block_index == 0 || block_index < bucket.size() - 1) {
			boolean swap_right = c.compare(curr_block, bucket.get(block_index + 1)) > 0;
			if (swap_right) {
				keepSwappingRight(bucket, c, block_index);
				return;
			}
		}
		if (block_index == bucket.size() - 1 || block_index > 0) {
			boolean swap_left = c.compare(curr_block, bucket.get(block_index - 1)) < 0;
			if (swap_left) {
				keepSwappingLeft(bucket, c, block_index);
			}
		}
	}

	/**
	 * Swaps the block at x with the block at y.
	 * @param bucket
	 * @param x
	 * @param y
	 */
	private static void swapBlock(ArrayList<int[]> bucket, int x, int y) {
		int[] temp = bucket.get(x);
		bucket.set(x, bucket.get(y));
		bucket.set(y, temp);
	}

	/**
	 * Keeps swapping the block at block_index towards the beginning of the bucket,
	 * @param bucket
	 * @param c
	 * @param block_index
	 */
	private static void keepSwappingLeft(ArrayList<int[]> bucket, Comparator<int[]> c, int block_index) {
		boolean swap_left = true;
		while (swap_left) {
			swapBlock(bucket, block_index, block_index - 1);
			block_index--;
			if (block_index == 0) {
				return;
			}
			swap_left = c.compare(bucket.get(block_index), bucket.get(block_index - 1)) < 0;
		}
	}

	/**
	 * Keeps swapping the block at block_index towards the end of the bucket,
	 * @param bucket
	 * @param c
	 * @param block_index
	 */
	private static void keepSwappingRight(ArrayList<int[]> bucket, Comparator<int[]> c, int block_index) {
		boolean swap_right = true;
		while (swap_right) {
			swapBlock(bucket, block_index, block_index + 1);
			block_index++;
			if (block_index == bucket.size() - 1) {
				return;
			}
			swap_right = c.compare(bucket.get(block_index), bucket.get(block_index + 1)) > 0;
		}
	}

	/**
	 * Prints the error message and exits the program.
	 * @param error_msg
	 */
	private void printError(String error_msg) {
		System.out.println(error_msg);
		System.exit(-1);
	}

	/**
	 * Tries to solve a sliding block puzzle.
	 * @param args
	 */
	public static void main(String[] args) {
		// read init and goal files and instantiate init and gaal
		Solver s = new Solver();
		s.createInitOrGoal(args[0], true);
		s.createInitOrGoal(args[1], false);

		// get more credit
		s.checkOptimizationPossibilities();
		// start searching
		s.searchPath();
	}

}
