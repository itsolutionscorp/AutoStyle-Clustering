import java.util.*;

/**
 * A class that represents a tray.
 */

public class Tray {
	
	/**
	 * A 3-D data structure that represents all the blocks including empty squares of the tray.
	 */
	ArrayList<ArrayList<int[]>> blocks;

	/**
	 * Number of trays that have been generated by the solver.
	 */
	private static int num_of_trays = 0; 

	/**
	 * An integer that represents the id of the tray which is determined from num_of_trays.
	 */
	int id; 

	/**
	 * A tray from which the current tray is generated.
	 * Since duplicate is checked before a tray is created and added to fringe, 
	 * there is only one parent for each tray (null for init and goal trays).
	 */
	private Tray parent;

	/**
	 * An integer that represents a guess of the tray's priority 
	 * -- the smaller the heuristic is, the higher the priority.
	 */
	int heuristic; 

	/**
	 * An array of 4 integers representing the move from the tray's parent to itself.
	 * The first two integers make up the current top-left coordinate of its parent, and
	 * the last two integers make up the top-left coordinate of itself.
	 */
	int[] move;

	/**
	 * A HashSet that contains all empty squares represented by their hash codes 
	 * generated by emptySquareHashCode() in Solver.
	 */
	HashSet<Integer> empty_squares; 
	
	/**
	 * An integer representing the default heuristic.
	 */
	private static final int DEFAULT_HEURISTIC = 0;

	/**
	 * Constructs a tray with the specified blocks, empty squares, and move.
	 * @param blocks
	 * @param empty_squares
	 * @param move
	 */
	public Tray(ArrayList<ArrayList<int[]>> blocks, HashSet<Integer> empty_squares, int[] move) {
		this.blocks = blocks; 
		this.id = num_of_trays;
		num_of_trays++;
		this.move = move;
		this.parent = null;
		this.heuristic = DEFAULT_HEURISTIC; 
		this.empty_squares = empty_squares; 
	}

	/**
	 * Constructs a tray with the specified blocks, empty squares, move, moved block, and parent.
	 * @param blocks
	 * @param empty_squares
	 * @param move
	 * @param moved_block
	 * @param parent
	 */
	public Tray(ArrayList<ArrayList<int[]>> blocks, HashSet<Integer> empty_squares,
			int[] move, int[] moved_block, Tray parent) {
		this.blocks = blocks; 
		this.id = num_of_trays;
		num_of_trays++;
		this.move = move;
		this.parent = parent;
		this.heuristic = calculateHeuristic(moved_block);
		this.empty_squares = empty_squares; 
	}

	/**
	 * Calculates the heuristic of the tray.
	 * @param moved_block
	 * @return the heuristic of the tray
	 */
	private int calculateHeuristic(int[] moved_block) {
		if (this.parent == null) {
			return DEFAULT_HEURISTIC;
		}
		int dim_moved_block = Solver.dimensionHashCode(moved_block[2] - (moved_block[0] + 1),
				moved_block[3] - (moved_block[1] + 1));
		for (int i = 0; i < Solver.goal.blocks.size() - 1; i++) {
			ArrayList<int[]> g_bucket = Solver.goal.blocks.get(i);
			// make sure g_bucket is not the empty bucket
			// invariant: the last bucket contains empty squares, so go through all buckets except
			// the last one		
			int[] goal_block = g_bucket.get(0);
			int dim_goal_block = Solver.dimensionHashCode(goal_block[2] - (goal_block[0] + 1),
					goal_block[3] - (goal_block[1] + 1));
			if (dim_moved_block == dim_goal_block) {
				// check which changes: height or width (look at move) 
				// if height changes, check whether height is closer or farther (width is unchanged) 
				// if width changes, check whether width is closer or farther (height is unchanged) 
				int delta_height = move[2] - move[0]; 
				int delta_width = move[3] - move[1];
				if (delta_height > 0) {
					// go to south
					boolean goal_is_south = (goal_block[0] > moved_block[0]); 
					if (goal_is_south) {
						return this.parent.heuristic - 1; // higher priority 
					} else {
						return this.parent.heuristic + 1; // lower priority
					}
				} else if (delta_height < 0) {
					// go to north 
					boolean goal_is_north = (goal_block[0] < moved_block[0]); 
					if (goal_is_north) {
						return this.parent.heuristic - 1; // higher priority 
					} else {
						return this.parent.heuristic + 1; // lower priority
					}
				} else if (delta_width > 0) {
					// go to east
					boolean goal_is_east = (goal_block[1] > moved_block[1]); 
					if (goal_is_east) {
						return this.parent.heuristic - 1; // higher priority 
					} else {
						return this.parent.heuristic + 1; // lower priority
					}
				} else {
					// go to west
					boolean goal_is_west = (goal_block[1] < moved_block[1]); 
					if (goal_is_west) {
						return this.parent.heuristic - 1; // higher priority 
					} else {
						return this.parent.heuristic + 1; // lower priority
					}
				}
			}
		}
		// should never reach here
		return this.parent.heuristic;
	}
}
