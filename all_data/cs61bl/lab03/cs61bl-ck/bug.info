{\rtf1\ansi\ansicpg1252\cocoartf1347\cocoasubrtf570
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 1) At first, contains1MoreThan only works when the added character is at the end of the original word\
\
2) It returns false correctly when there too many or too little different letters.\
\
3) There aren\'92t any\
\
4) The code returns false incorrectly when the letter added is at the beginning because due to the last else statement not checking the object but rather the reference variables. It also incorrectly returns false when the character is added in the middle due to the second else-if statement checking the character values at the 0th position (however, this is the same bug because the recursion always shortens the word one letter and one extra letter in the middle will eventually become one extra letter at the beginning).\
\
5) it crashed when you add too many or too little arguments as well as putting in a null.\\\
\
The bug came about from trying to compare two different objects with the same contents using the \'93==\'93 operator. For strings, this only checks the reference pointers and even if they do have the same word, it will return false due to the words being different objects. To fix this, you would use a .equals method from the string class.}